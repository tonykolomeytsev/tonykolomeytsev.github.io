+++
title = "Деплой на роботов с Docker"
date = "2023-08-27"

[taxonomies]
tags = ["robotics", "eurobot", "skoltech", "docker"]
+++

# Предыстория

> Эта статья не предназначена для объяснений сути Eurobot. Если вы не знакомы со спецификой соревнований Eurobot, лучше сначала ознакомиться c [официальным сайтом](https://www.eurobot.org/eurobot-contest/) и [YouTube каналом](https://www.youtube.com/live/BvLpiho28uI?si=m2owafdwym0hwJIT&t=1405).

С сентября 2022 года по май 2023 я был частью команды [RESET](https://www.skoltech.ru/2023/05/reset-stal-chempionom-sorevnovanij-avtonomnyh-robotov-eurobot-russia-2023/) из [Сколтеха](https://www.skoltech.ru/). И мы готовились к соревнованиям по робототехнике [Eurobot 2023](https://www.eurobot.org/eurobot-contest/eurobot-2023/).

В команде RESET выстроена преемственность — участники соревнований прошлого года выступают наставниками для участников нового года. Преемственность сохранялась также и в том, как происходил деплой/доставка софта на роботов.

## Дедовский способ доставки

Из года в год разработка под роботов происходила примерно одинаково. Заводился Git репозиторий в GitLab, локальная копия репозитория была и на ноутбуках участников, и на роботах. Когда участники команды вносили изменения локально у себя на компах, для переноса на робота они пушили изменения в GitLab репозиторий, а потом подтягивали (pull) изменения на роботе.

К роботам подключались клавиатуры, мыши и мониторы. С помощью этих же устройств на роботах запускали тот код, что был написан ранее. Иногда код редактировали прямо на роботах, ~~это же так удобно, клава и монитор уже подключены~~. Потом эти правки пушили в GitLab.

<center>

![Deploy old way](deploy-old-way.svg)

</center>

Да, так можно делать, это самое очевидное и лежащее на поверхности решение. Но оно приводит к серьезнейшим проблемам:

1. **Конфликты зависимостей**

    Над софтом для каждого робота работают несколько участников команды. Кто-то пишет на Python, кто-то на C++. Возникали ситуации, когда версии библиотек в одних ROS пакетах конфликтовали в версиями библиотек из других.

1. **Невоспроизводимость (irreproducibility)**

    Никто не может гарантировать что после сноса или переустановки системы тот же самый код будет работать как раньше.

2. **Сопряженность (coupling)**

    Все пакеты разрабатываются и запускаются в одном окружении и вообще ничто не мешает сломать чужой код, даже не меняя его.

3. **Время билда**

    Код на C++ отдельно билдится на компах участников. А после попадания на робота этот же код билдится заново уже на роботе. Роботом в этот момент пользоваться нельзя.

4. **Бонусная мемная проблема: очереди**

    Вся работа с роботом ведется через клавиатуру, мышку и монитор. Придется подождать, пока другой участник сделает на роботе все что ему надо и освободит рабочее место.

## Повод нарушить традиции

В 2022 году один из наставников предложил изменить подход к разработке и попробовать запускать код на роботе в Docker контейнерах. В тот год в команду RESET как раз пришел айтишник (это я).

<center>

![Я в этом шарю](tom-meme.jpeg)

*Ребята, я в этом шарю*

</center>

Изначально при помощи Docker планировалось победить совсем другие проблемы, но позже оказалось, что этот подход почти во всем лучше старого.

# Окей, переходим на Docker

## Сформулируем требования

В "айтишной" части команды RESET было 4 человека:

1. Разработчик BehaviorTree и всей обвязки (это я).
2. Разработчик системы локализации.
3. Разработчик системы навигации.
4. Разработчик алгоритмов CV.

Изначально переход на Docker планировался ради того, чтобы было легко запускать и останавливать ROS ноды на роботе. Все потому что наш наставник уже знал про такие штуки, как оркестраторы Docker.

Решили, что каждый будет делать свой "микросервис" со своими ROS пакетами, не зависимыми от пакетов других разрабов. В ходе обсуждений мы поняли, что Docker также дает возможность прогать и тестировать каждый "микросервис" в изоляции от остальных. Единственной проблемой была необходимость публикации образов в облачных репозиториях. Мы хотели избежать использования интернета при передаче образов на роботов.

Таким образом требования следующие:

- Каждый разраб работает со своими Docker образами и не лезет в чужие.
- Разрабы должны иметь возможность пушить образы на роботов в локальной сети, избегая публикации в интернете.
- Разрабы не должны сильно шарить в Docker, все должно работать просто и интуитивно.

> **Спойлер:** Мы смогли всего добиться, попутно решив все описанные в начале статьи проблемы.

## Как здоровые люди деплоят с Docker

В дикой айтишной природе люди упаковывают свои приложения в Docker образы и загружают их в репозитории (registry). Самый крупный публичный репозиторий с образами это [Docker Hub](https://hub.docker.com/).

Репозитории могут быть и приватными. Такие, например, создают для себя компании, чтобы приложения, разрабатываемые внутри них, были доступны только сотрудникам. 

Но суть в том что репозитории всегда находятся на удаленных серверах и для того чтобы обмениваться с ними Docker образами, нужно подключение к интернету. Это не проблема, когда вы бекендер и публикуете свой микросервис: и репозиторий, и сервер, на который доставляется приложение, находятся хрен знает где и оба подключены к интернету 24 на 7.

А что если доставлять Docker образ с ноутбука по локальной сети прямо на робота?