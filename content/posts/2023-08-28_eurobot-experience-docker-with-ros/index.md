+++
title = "Опыт Eurobot: ROS2 вместе с Docker"
date = "2023-08-28"

[taxonomies]
tags = ["docker", "ROS", "robotics", "eurobot", "skoltech", "practical case"]
+++

Если вы не знакомы со спецификой соревнований Eurobot, лучше сначала ознакомиться c [официальным сайтом](https://www.eurobot.org/eurobot-contest/) и [YouTube каналом](https://www.youtube.com/live/BvLpiho28uI?si=m2owafdwym0hwJIT&t=1405).

С сентября 2022 года по май 2023 я был частью команды [RESET](https://www.skoltech.ru/2023/05/reset-stal-chempionom-sorevnovanij-avtonomnyh-robotov-eurobot-russia-2023/) из [Сколтеха](https://www.skoltech.ru/). И мы готовились к соревнованиям по робототехнике [Eurobot 2023](https://www.eurobot.org/eurobot-contest/eurobot-2023/).

# Предпосылки использования Docker

> До моего прихода в команде RESET не использовали Docker, поэтому совершенный нами переход можно назвать большим шагом вперед.

## Проект с кодом для роботов на ROS
<!-- Тут рассказать про то, что из себя представляют проекты на ROS и как взаимодействуют между собой -->

В последние годы команда RESET разрабатывает софт для роботов на базе [ROS](https://www.ros.org/). Это удобно, из-за того что ROS позволяет быстро прототипировать функционал, неплохое решение для соревновательной робототехники.

Я не буду полностью расписывать принципы работы ROS, для этого есть [официальные туториалы](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools.html), но расскажу концепты, важные для текущей статьи. Главная фишка, которую дает ROS — модульность. Вы можете вести разработку подсистем робота в отдельных проектах/репозиториях, устанавливать чужие пакеты, а потом заставить все это работать вместе. Например, системы навигации, управления приводами и принятия решений могут быть разными приложениями, запускаемыми по-отдельности. ROS предоставляет интерфейс для обмена данными между приложениями.

### Пакеты

Самая крупная "программная единица" в ROS, это пакет (package).
**Пакет** — это один проект на С++ или Python, с файлом `package.xml` в корне и c подключенными библиотеками ROS.

<center>

![ROS with Packages](ros-packages.svg)

</center>

### Ноды

Каждый пакет в ROS может содержать в себе ограниченное здравым смыслом количество нод (node). **Ноды** — это программные сущности, при помощи которых разработчики взаимодействуют со всеми плюшками ROS. В библиотеках C++ и Python ноды это просто классы, от которых надо наследоваться, чтобы создать свои собственные ноды.

Если вы вообще не понимаете о чем речь, лучше ознакомиться с [официальным туториалом](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes.html).

<center>

![ROS with Packages and Nodes](ros-packages-nodes.svg)

</center>

### Топики

Приложения сторонних разработчиков могут запускать свои ноды, мы можем запускать свои. Обмен данными между всеми нодами происходит при помощи топиков (topics). **Топик** — это шина данных со своим именем и типом данных. Ноды могут как сами публиковать данные в топики, так и прослушивать топики ожидая данных.

<center>

![ROS with Packages, Nodes and Topics](ros-packages-nodes-topics.svg)

</center>

Для тех кому интересно: данные сериализуются в бинарный формат и передаются между процессами. Пока что примем, что это происходит при помощи черной магии. Для большего количества подробностей гляньте [официальное объяснение топиков](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html).

## Опыт участников предыдущих лет
<!-- Тут рассказать про то, из чего вообще состоял проект (много реп) и как код разворачивали на роботах -->

Опыт команды RESET таков, что из примерно десяти человек, четверо занимаются написанием кода для роботов. Все потому что было выделено 4 направления разработки:

1. Программирование стратегии, поведения робота на поле (**behavior tree**).
2. **Локализация**, работа с лидаром и одометрией.
3. **Навигация**, обработка данных с локализации, передвижение робота по полю.
4. **Компьютерное зрение**.

До нашего прихода программисты в команде RESET использовали понятие "модульности" на максимум. Поэтому каждый писал свои ROS пакеты в отдельном репозитории. Все репозитории хранились на GitLab и клонировались на роботов. На роботах писались `*.sh` скрипты, при помощи которых происходила компиляция и синхронный запуск всех пакетов.

Ребята активно использовали этот подход и сталкивались со следующими проблемами:

1. **Конфликты зависимостей**

    Над софтом для каждого робота работают несколько участников команды. Кто-то пишет на Python, кто-то на C++. Все пакеты в итоге устанавливались в одну систему. Возникали ситуации, когда версии библиотек в одних ROS пакетах конфликтовали в версиями библиотек из других.

1. **Невоспроизводимость (irreproducibility)**

    Никто не может гарантировать что после переустановки системы тот же самый набор пакетов будет работать как раньше.

2. **Сопряженность (coupling)**

    Ничто не мешает сломать чужой код, даже не меняя его. Достаточно просто обновить какую-нибудь библиотеку.

3. **Время билда**

    Код на C++ отдельно билдится на компах участников. А после попадания на робота этот же код билдится заново уже на роботе. Роботом в момент компиляции пользоваться нельзя.

4. **Мемная проблема: очереди**

    Вся работа с роботом ведется через клавиатуру, мышку и монитор. Приходится ждать, пока другой участник сделает на роботе все что ему надо и освободит рабочее место.

## Триггер изменений
<!-- Тут рассказать про предложение использовать докер и первичные причины, по которым хотелось его использовать -->

В 2022 году один из наставников предложил изменить подход к разработке и попробовать запускать код на роботе в Docker контейнерах. В тот год в команду RESET как раз пришел айтишник (это я).

<center>

![Я в этом шарю](tom-meme.jpeg)

*Ребята, я в этом шарю*

</center>

Я уже не помню, почему изначально наставник предлагал перейти на Docker. Вроде, потому что запускать и останавливать контейнеры проще, чем процессы ROS. Это уже не важно. Важно, что практика деплоя с Docker внедрена в айтишке повсеместно. Вы не найдете сейчас ни одного бэкендера, который бы не упаковывал свои приложения в образы.

Образы это круто:
- Вы вообще исключаете проблемы с воспроизводимостью. Если упакованное приложение работает у вас на компьютере, то и на другой машине оно заработает.
- Вы не паритесь даже по поводу ОС, на которой будет запущено ваше приложение.
- Приложения легко доставлять до конечной машины, на которой оно будет запущено.
- Для запуска упакованного приложения нужен только установленный Docker.

В общем, так мы и начали путешествие от сохи к ракете.

# Переходим на Docker

## Терминология

## Новая структура проекта
<!-- Тут рассказать про то, как перешли на монорепу, какую структуру заложили в нее, какие преимущества и недостатки -->

## Dockerfile для воркспейса
<!-- Тут рассказать про структуру докерфайла в каждом воркспейсе -->

## Расшаривание общего кода между воркспейсами
<!-- Тут рассказать про расшаривание воркспейса `common` между другими воркспейсами и почему это не самое плохое решение с точки зрения ROS -->

## Сборка кода воркспейсов во время разработки
<!-- Тут рассказать про то, как собирался код воркспейсов во время разработки и отладки -->

## Сборка воркспейса в Docker образ
<!-- Тут рассказать про то, как проходит процесс сборки воркспейса в Docker образ -->

## Отправка образов на роботов
<!-- Эта часть слишком большая, оставить ссылку на следующую статью -->

## Запуск и остановка контейнеров на роботе
<!-- Тут рассказать про запуск докера из терминала путем вызова docker run -->

## Выходим на новый уровень менеджмента контейнеров
<!-- Тут рассказать про docker-compose -->

# Важные мелочи

## Использование .env файла
<!-- Тут рассказать про то, как не редачить постоянно docker-compose.yaml -->

## Использование кастомного ROS DDS
<!-- Тут рассказать про проблемы с работой дефолтного DDS в сети Docker -->

# К чему мы в итоге пришли

## Явные улучшения
<!-- Тут перечислить список проблем из начала статьи и рассказать как они исчезли 

- можно использовать образы с разными версиями ROS
-->

## Что можно улучшить
<!-- Тут рассказать про проблемы, возникающие из-за использования Docker -->

## Что я не затронул в статье
<!-- Заполнить после того как напишу статью -->
