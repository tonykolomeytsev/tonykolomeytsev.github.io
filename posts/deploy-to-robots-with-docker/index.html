<!doctype html><html dir=auto lang=en><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="index, follow" name=robots><meta content=mmSUCWwptqJJuCzIwQO7JyFJ4dbxkrHO92nV7PBwRIg name=google-site-verification><title>Опыт Eurobot: Деплой Docker образов на роботов в локальной сети</title><meta content="android, development, tech, robotics" name=keywords><meta name=description><meta content="Anton Kolomeytsev" name=author><link href=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/ rel=canonical><link href=https://tonykolomeytsev.github.io/css/includes/scroll-bar.css rel=stylesheet><link href=https://tonykolomeytsev.github.io/css/styles.css rel=stylesheet><link href=https://tonykolomeytsev.github.io/css/override.css rel=stylesheet><link href=https://tonykolomeytsev.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><noscript><style>#theme-toggle,.top-link{display:none}</style> <style>@media (prefers-color-scheme:dark){:root {--theme:#1d1e20;--entry:#2e2e33;--primary:#dadadb;--secondary:#9b9c9d;--tertiary:#414244;--content:#c4c4c5;--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark):-webkit-scrollbar-track {background:0 0}.list:not(.dark):-webkit-scrollbar-thumb {border:var(--theme)}}</style></noscript><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark')}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark')}</script><header class=header><nav class=nav><div class=logo><a title="Kekmech (Alt + H)" accesskey=h href=https://tonykolomeytsev.github.io> Kekmech </a><div class=logo-switches><button title="(Alt + T)" accesskey=t id=theme-toggle><svg viewbox="0 0 24 24" fill=none height=18 id=moon stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> <svg viewbox="0 0 24 24" fill=none height=18 id=sun stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></button><ul class=lang-switch><li></ul></div></div><ul id=menu><li><a href=https://tonykolomeytsev.github.io/archive title=Archive> <span>Archive</span> </a><li><a href=https://tonykolomeytsev.github.io/tags title=Tags> <span>Tags</span> </a></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tonykolomeytsev.github.io>Home</a> »  <a href=https://tonykolomeytsev.github.io/posts/>Posts</a> »  <a href=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/>Опыт Eurobot: Деплой Docker образов на роботов в локальной сети</a></div><h1 class=post-title>Опыт Eurobot: Деплой Docker образов на роботов в локальной сети</h1><div class=post-meta><span title="2023-09-06 00:00:00 +0000">2023-09-06</span> · 13 min · 2418 words · Anton Kolomeytsev  | <a rel="noopener noreferrer" href=https://github.com/tonykolomeytsev/tonykolomeytsev.github.io/tree/master/content/posts/2023-09-06_deploy_to_robots_with_docker/index.md target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary title="(Alt + C)" accesskey=c><span class=details>Table of Contents</span></summary> <div class=inner><ul><li><a aria-label=Мотивация href=#motivatsiia>Мотивация</a><li><a aria-label="Самое простое решение" href=#samoe-prostoe-reshenie>Самое простое решение</a><li><a aria-label="Самое сложное решение" href=#samoe-slozhnoe-reshenie>Самое сложное решение</a> <ul><li><a aria-label="Шаг 0: Предварительная настройка" href=#shag-0-predvaritel-naia-nastroika>Шаг 0: Предварительная настройка</a> <ul><li><a aria-label="Настраиваем SSH-ключи" href=#nastraivaem-ssh-kliuchi>Настраиваем SSH-ключи</a><li><a aria-label="Docker BuildKit" href=#docker-buildkit>Docker BuildKit</a><li><a aria-label="Создание и настройка BuildKit Builder" href=#sozdanie-i-nastroika-buildkit-builder>Создание и настройка BuildKit Builder</a></ul><li><a aria-label="Шаг 1: Собираем образ локально" href=#step-1>Шаг 1: Собираем образ локально</a><li><a aria-label="Шаг 2: Поднимаем Docker Registry на роботе" href=#shag-2-podnimaem-docker-registry-na-robote>Шаг 2: Поднимаем Docker Registry на роботе</a><li><a aria-label="Шаг 3: Поднимаем SSH туннель между роботом и компьютером" href=#shag-3-podnimaem-ssh-tunnel-mezhdu-robotom-i-komp-iuterom>Шаг 3: Поднимаем SSH туннель между роботом и компьютером</a> <ul><li><a aria-label="Бонус: проверяем что все работает" href=#bonus-proveriaem-chto-vse-rabotaet>Бонус: проверяем что все работает</a></ul><li><a aria-label="Шаг 4: Пушим образ в Docker Registry на роботе" href=#shag-4-pushim-obraz-v-docker-registry-na-robote>Шаг 4: Пушим образ в Docker Registry на роботе</a><li><a aria-label="Шаг 5: Чистим за собой" href=#shag-5-chistim-za-soboi>Шаг 5: Чистим за собой</a></ul><li><a aria-label="Подводные камни" href=#podvodnye-kamni>Подводные камни</a> <ul><li><a aria-label="Комментарий по поводу Mac OS" href=#mac-os-specific>Комментарий по поводу Mac OS</a><li><a aria-label="Расход места на диске" href=#raskhod-mesta-na-diske>Расход места на диске</a><li><a aria-label="Этот процесс нуждается в автоматизации" href=#etot-protsess-nuzhdaetsia-v-avtomatizatsii>Этот процесс нуждается в автоматизации</a></ul><li><a aria-label="Мысли напоследок" href=#mysli-naposledok>Мысли напоследок</a></ul></div></details></div><div class=post-content><p>Продолжая серию постов про Eurobot, рассказываю про следующую деталь нашей инфраструктуры — доставку Docker образов до роботов в обход интернета и удаленных Docker Registry.<p><a href=/posts/eurobot-experience-docker-with-ros/>В предыдущем посте</a> я рассказал о том, как мы собирали Docker образы и как контейнеры запускались на роботах. В этот раз покажу, как эти самые образы по Wi-Fi доставлять с машин разработчиков на роботов.<p>Для опытных бэкендеров скорее всего материал поста не будет новым. Для меня же большая часть описанного здесь в свое время стала откровением.</p><center> <p><img alt="Deploying Docker App" src=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/deploying-app.jpg></p> <p><em>Именно так выглядит деплой</em></p> </center><h1 id=motivatsiia>Мотивация<a aria-hidden=true class=anchor hidden href=#motivatsiia>#</a></h1><p>Во время подготовки к соревнованиям мы использовали как классический подход доставки образов, через Docker Hub, так и эзотерический — по локальной сети.<p>Первый способ мы использовали в основном, загружая в Docker Hub стабильные образы, собранные из ветки master на CI в нашем репозитории. Мы точно знали что в публичном репозитории находятся рабочие образы и иногда откатывались к ним.<p>По локальной сети же мы деплоили в 99% случаев, находясь физически в лабе и отлаживая роботов вечерами после пар.<p>Таким образом, заливать образы минуя интернет я хотел по двум причинам:<ol><li>Это тупо быстрее и удобнее.<li>На соревнованиях, куда мы приедем, может не быть интернета или он может быть нестабилен.</ol><h1 id=samoe-prostoe-reshenie>Самое простое решение<a aria-hidden=true class=anchor hidden href=#samoe-prostoe-reshenie>#</a></h1><p>Первое решение, которое мне пришло в голову, <a href=https://stackoverflow.com/questions/23935141/how-to-copy-docker-images-from-one-host-to-another-without-using-a-repository>пришло в голову кому-то еще до меня</a>. Заключалось решение в следующем:<ol><li>Собираем Docker образ.<li>Экспортируем образ в tar архив.<li>Отправляем tar архив при помощи <code>rsync</code> или <code>scp</code> на робота.<li>На роботе импортируем tar архив обратно в образ.</ol><p>Решение железное и супер понятное, но во всем остальном оно ужасно:<ul><li>Вы тратите время не только на сборку образа, но и на его экспорт. Экспорт ROS образов у нас занимал 20-30 секунд.<li>Нельзя отправить только изменившиеся слои образа, придется каждый раз отправлять ВЕСЬ образ.<li>Образы с ROS весят больше гигабайта, и даже архивирование их не спасает. Передача таких тяжелых образов сама по себе будет съедать пару минут времени (я проверял).</ul><p>Я реализовал этот способ, понял что он работает ужасно долго и для нас он не подходит. Поэтому тратить буквы на него не буду, сразу перейду к объяснению финального решения.<h1 id=samoe-slozhnoe-reshenie>Самое сложное решение<a aria-hidden=true class=anchor hidden href=#samoe-slozhnoe-reshenie>#</a></h1><blockquote><p>Если вы повторяете описанные здесь шаги на MacOS, вам нужно знать <a href=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/#mac-os-specific>кое-что важное</a>.</blockquote><p>Оптимальное решение работает следующим образом:<ol><li>Собираем образ локально на своем лэптопе/ПК/микроволновке.<li>По SSH запускаем на роботе Docker Registry.<li>Поднимаем SSH туннель между вашей машиной и роботом, чтобы Docker Registry робота стал доступен в локальной сети.<li>Пушим собранный вами локально образ в Docker Registry, расположенный на роботе.<li>Освобождаем неиспользуемые ресурсы.</ol><p>Прежде чем проделывать все эти шаги, нужно кое-что настроить на своей машине. Но самое главное — на роботе должен быть установлен Docker, и запускаться он должен без sudo (<a href=https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user>Manage Docker as a non-root user</a>).<h2 id=shag-0-predvaritel-naia-nastroika>Шаг 0: Предварительная настройка<a aria-hidden=true class=anchor hidden href=#shag-0-predvaritel-naia-nastroika>#</a></h2><h3 id=nastraivaem-ssh-kliuchi>Настраиваем SSH-ключи<a aria-hidden=true class=anchor hidden href=#nastraivaem-ssh-kliuchi>#</a></h3><blockquote><p>Я настоятельно рекомендую один раз выполнить этот пункт, в противном случае работоспособность кода ниже уже будет под вопросом, а удобство использования гарантированно пострадает.</blockquote><p>SSH-ключи, это более безопасная альтернатива паре логин/пароль, позволяющая один раз "зарегистрировать" ваш лэптоп в пямяти робота и далее входить с того же устройства уже без ввода пароля. Нормальное объяснение SSH-ключей: <a href=https://selectel.ru/blog/ssh-keys/>ТЫК</a>.<h4 id=proveriaem-chto-kliuch-uzhe-est>Проверяем что ключ уже есть<a aria-hidden=true class=anchor hidden href=#proveriaem-chto-kliuch-uzhe-est>#</a></h4><p>Проверить, что у вас уже есть SSH-ключ на устройстве, можно при помощи команды ниже:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>ls ~</span><span style=color:#abb2bf>/.ssh/
</span></code></pre><p>Если в списке файлов будут <code>id_rsa</code> и <code>id_rsa.pub</code>, новый ключ генерировать не нужно.<h4 id=generiruem-ssh-kliuch>Генерируем SSH-ключ<a aria-hidden=true class=anchor hidden href=#generiruem-ssh-kliuch>#</a></h4><p>Если у вас еще нет SSH ключа на устройстве, нужно <a href=https://selectel.ru/blog/tutorials/how-to-generate-ssh/>выпустить новый</a>. Команда для выпуска ключа следующая:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>ssh-keygen -t</span><span style=color:#abb2bf> rsa
</span></code></pre><p>Пароль для SSH-ключа ставить не надо.<h4 id=registriruem-ssh-kliuch-na-robote>Регистрируем SSH-ключ на роботе<a aria-hidden=true class=anchor hidden href=#registriruem-ssh-kliuch-na-robote>#</a></h4><p>В команде ниже:<ul><li><code>user</code> — имя юзера в ОС робота. У нас в RESET имя юзера всегда было <code>nuc</code>.<li><code>host</code> — IP-адрес робота в локальной сети, например <code>192.168.1.64</code>.</ul><p>Код для Linux/MacOS:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>ssh-copy-id</span><span style=color:#abb2bf> user@host
</span></code></pre><p><a href=https://chrisjhart.com/Windows-10-ssh-copy-id/>Код для Windows Powershell</a> немного отличается:<pre class=language-powershell data-lang=powershell style=background:#2b303b;color:#6c7079><code class=language-powershell data-lang=powershell><span style=color:#abb2bf>type </span><span style=color:#eb6772>$env:USERPROFILE</span><span style=color:#abb2bf>\.ssh\id_rsa.pub </span><span style=color:#adb7c9>|</span><span style=color:#abb2bf> ssh user</span><span style=color:#eb6772>@host </span><span style=color:#9acc76>"cat >> .ssh/authorized_keys"
</span></code></pre><h3 id=docker-buildkit>Docker BuildKit<a aria-hidden=true class=anchor hidden href=#docker-buildkit>#</a></h3><p><a href=https://docs.docker.com/build/buildkit/>BuildKit</a> это новый бэкенд для Docker, который нам нужен конкретно из-за своей способности билдить образы под разные архитектуры процессоров.<p>Убедитесь что на вашем компе установлен один из трех вариантов софта с BuildKit внутри:<ul><li>Docker Desktop — рекомендую ставить именно его и не париться.<li>Docker версии 23.0 и выше.<li>Старая версия Docker с <a href=https://docs.docker.com/build/buildkit/>установленным BuildKit</a> — хз зачем вам вообще может понадобится эта опция.</ul><center> <p><img alt="Docker Desktop Screenshot" src=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/docker-desktop-screenshot.png></p> </center><h3 id=sozdanie-i-nastroika-buildkit-builder>Создание и настройка BuildKit Builder<a aria-hidden=true class=anchor hidden href=#sozdanie-i-nastroika-buildkit-builder>#</a></h3><p>Builder — Docker контейнер с эмулятором, который умеет собирать Docker образы под разные архитектуры процессоров. Если вы уже установили Docker, то один билдер с именем <code>default</code> у вас уже автоматически создан.<p>Нам нужно создать новый билдер и передать в него наш конфиг <code>buildkitd.default.toml</code>:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>docker</span><span style=color:#abb2bf> buildx create \
</span><span style=color:#eb6772>    --name</span><span style=color:#abb2bf> eurobot-builder \
</span><span style=color:#eb6772>    --config</span><span style=color:#abb2bf> buildkitd.default.toml \
</span><span style=color:#eb6772>    --bootstrap --use
</span></code></pre><p>Опция <code>--bootstrap</code> сразу запустит билдер, опция <code>--use</code> сделает его билдером по-умолчанию.<p>Заводить свой билдер нужно из-за того, что из коробки Docker не позволяет отправлять образы куда-либо, кроме защищенных цифровой подписью репозиториев в интернетах. В конфиге <code>buildkitd.default.toml</code> разрешаем пушить образы по адресу <code>localhost:5000</code>:<pre class=language-toml data-lang=toml style=background:#2b303b;color:#6c7079><code class=language-toml data-lang=toml><span style=color:#abb2bf>[registry.</span><span style=color:#9acc76>"host.docker.internal:5000"</span><span style=color:#abb2bf>]
</span><span style=color:#eb6772>http </span><span style=color:#abb2bf>= </span><span style=color:#db9d63>true
</span></code></pre><p>Вы можете возмутиться: откуда тут <code>host.docker.internal:5000</code>?<p>Ответ: билдеры это обычные Docker контейнеры, им недоступна ваша локальная сеть по адресу <code>localhost</code>. Чтобы обойти эту проблему, в Docker есть специальный алиас <code>host.docker.internal</code>, ведущий в "настоящую" локальную сеть вашего компьютера. Про алиас и конкретно наш юзкейс можно почитать подробнее в <a href=https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host>документации Docker</a>.<h2 id=step-1>Шаг 1: Собираем образ локально<a aria-hidden=true class=anchor hidden href=#step-1>#</a></h2><p>Наконец-то собираем образ. Для этого в директории с <code>Dockerfile</code> запускается примерно вот такой код:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>docker</span><span style=color:#abb2bf> buildx build \
</span><span style=color:#eb6772>    --platform</span><span style=color:#abb2bf> linux/amd64 \
</span><span style=color:#eb6772>    --tag</span><span style=color:#abb2bf> eurobot2023:latest \
</span><span style=color:#eb6772>    --output</span><span style=color:#abb2bf> type=image,push=false \
</span><span style=color:#abb2bf>    .
</span></code></pre><p>Разберем по порядку:<ol><li>Запускаем билд с помощью <code>docker buildx build</code> — явно сообщаем Docker чтобы он использовал BuildKit.<li>Опция <code>--platform</code> определяет, <a href=https://docs.docker.com/engine/reference/commandline/buildx_build/#platform>под какую архитектуру будет сбилжен образ</a>. Билдить надо под архитектуру компьютера, который установлен на роботе. Например: <ul><li>Intel NUC это <code>linux/amd64</code>,<li>Raspberry Pi 3B+ это <code>linux/arm/v7</code>,<li>Raspberry Pi 4 и Nvidia Jetson Nano это <code>linux/arm64</code> и так далее.</ul><li>Опция <code>--output</code> позволяет указать, <a href=https://docs.docker.com/engine/reference/commandline/buildx_build/#output>что делать с результатом билда</a>. В нашем случае это <code>type=image,push=false</code> — собираем OCI образ, никуда не пушим, в Docker не экспортируем: <ul><li>Не тратится время на экспорт образов в Docker. Так общее время билда сокращается.<li>Сбилженные образы хранятся в кэше, их не видно в приложении Docker Desktop или при вызове <code>docker images</code>. Таким образом частый билд не засирает вам список ваших образов.</ul></ol><h2 id=shag-2-podnimaem-docker-registry-na-robote>Шаг 2: Поднимаем Docker Registry на роботе<a aria-hidden=true class=anchor hidden href=#shag-2-podnimaem-docker-registry-na-robote>#</a></h2><p>Docker Registry дает одно из основных преимуществ подхода — инкрементальную отправку образов. Docker во время отправки общается с Registry и узнает какие слои образов надо отправлять, а какие нет. Нам нужно только подключиться к этому Registry, остальное будет сделано за нас.<p>Я использовал примерно вот такой код, для того чтобы через SSH запустить на роботе Registry:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>ssh -o</span><span style=color:#abb2bf> ConnectTimeout=5 \
</span><span style=color:#eb6772>    -o</span><span style=color:#abb2bf> StrictHostKeyChecking=no \
</span><span style=color:#eb6772>    -o</span><span style=color:#abb2bf> UserKnownHostsFile=/dev/null \
</span><span style=color:#abb2bf>    $</span><span style=color:#eb6772>ROBOT_HOSTNAME </span><span style=color:#9acc76>"
</span><span style=color:#9acc76>        docker run -d </span><span style=color:#5ebfcc>\
</span><span style=color:#9acc76>            -v /etc/docker-push-ssh/registry:/var/lib/registry </span><span style=color:#5ebfcc>\
</span><span style=color:#9acc76>            --name registry </span><span style=color:#5ebfcc>\
</span><span style=color:#9acc76>            --restart always </span><span style=color:#5ebfcc>\
</span><span style=color:#9acc76>            -p 127.0.0.1:5000:5000 </span><span style=color:#5ebfcc>\
</span><span style=color:#9acc76>            registry:2 || true
</span><span style=color:#9acc76>    "
</span></code></pre><blockquote><p>На Windows нет <code>/dev/null</code>, зато <a href=https://stackoverflow.com/questions/67372030/how-to-write-to-a-null-device-file-on-windows-10-so-i-can-not-read-back-wh>есть</a> <code>\\.\NUL</code>.</blockquote><p>Разбираем по порядку:<ol><li><p>Подключаемся по SSH к <code>$ROBOT_HOSTNAME</code>. Это как раз <code>user@host</code> из пункта про SSH-ключи — например <code>nuc@192.168.1.64</code>.</p><li><p>Опцию <code>-o ConnectTimeout=5</code> вы и сами сможете нагуглить.</p><li><p>Опции <code>-o StrictHostKeyChecking=no</code> и <code>-o UserKnownHostsFile=/dev/null</code> нужны для <a href=https://wiki.enchtex.info/practice/ssh_accept_host_key>автоматического принятия RSA ключей</a> клиентом SSH. Это сделано для удобства, чтобы вас никто не спрашивал "ДЕЙСТВИТЕЛЬНО ХОТИТЕ ПОДКЛЮЧИТЬСЯ?" и для того чтобы у вас не разрастался файл <code>known_hosts</code> при смене IP адресов роботов.</p><li><p>После установки соединения мы просто запускаем на роботе контейнер с Docker Registry. По-умолчанию Registry работает на порте 5000, при помощи биндинга <code>-p 127.0.0.1:5000:5000</code> мы делаем его доступным <a href=https://brokkr.net/2022/03/29/publishing-docker-ports-to-127-0-0-1-instead-of-0-0-0-0/>только в локальной сети</a>.</p> <blockquote><p>Образ с Registry весит в районе 20 мегабайт и в режиме бездействия не потребляет фактически никаких ресурсов. Так что если он будет все время работать, ничего плохого не произойдет даже на слабых компах типа Raspberry 3B+. Кстати, вместо <code>|| true</code> можно придумать более элегантное решение.</blockquote></ol><h2 id=shag-3-podnimaem-ssh-tunnel-mezhdu-robotom-i-komp-iuterom>Шаг 3: Поднимаем SSH туннель между роботом и компьютером<a aria-hidden=true class=anchor hidden href=#shag-3-podnimaem-ssh-tunnel-mezhdu-robotom-i-komp-iuterom>#</a></h2><p>SSH-туннель нужен для того чтобы сущности, доступные только в локальной сети робота стали доступны в локальной сети вашего компьютера. Если вы играли с друзьями в компик по Hamachi, можете воспринимать SSH-туннель как что-то подобное, <del>но это все-таки другое</del>.<p>Используем утилиту SSH:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>ssh -N </span><span style=color:#abb2bf>\
</span><span style=color:#eb6772>    -o</span><span style=color:#abb2bf> StrictHostKeyChecking=no \
</span><span style=color:#eb6772>    -o</span><span style=color:#abb2bf> UserKnownHostsFile=/dev/null \
</span><span style=color:#eb6772>    -L </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>:5000:localhost:5000 \
</span><span style=color:#abb2bf>    $</span><span style=color:#eb6772>ROBOT_HOSTNAME </span><span style=color:#abb2bf>\
</span><span style=color:#abb2bf>    </span><span style=color:#adb7c9>& </span><span style=color:#5ebfcc>echo </span><span style=color:#abb2bf>$</span><span style=color:#eb6772>! </span><span style=color:#adb7c9>></span><span style=color:#abb2bf> SSHPID
</span></code></pre><p>Разбираем что происходит:<ol><li>Подключаемся по SSH к <code>$ROBOT_HOSTNAME</code> (к <code>user@host</code>).<li>Опция <code>-N</code> позволяет не запускать никакую команду.<li>Опция <code>-L *:5000:localhost:5000</code> пробрасывает порты из сети нашего компьютера в локальную сеть робота. Таким образом нам будет доступен Docker Registry, запущенный на роботе.<li>Сам запуск ssh блокирует терминал, поэтому используем <code>&</code> чтобы запустить процесс в фоне и сразу записываем ID процесса в файл <code>SSHPID</code> для того чтобы закрыть тоннель после деплоя.</ol><blockquote><p>На Windows, в PowerShell <a href=https://www.reddit.com/r/PowerShell/comments/105e4gc/how_to_run_a_process_in_background_in_powershell/>до 7 версии</a>, конструкция <code>& echo $! > SSHPID</code> работать не будет. В рамках туториала можно просто запустить ssh, после чего продолжить работу в новом терминале.</blockquote><h3 id=bonus-proveriaem-chto-vse-rabotaet>Бонус: проверяем что все работает<a aria-hidden=true class=anchor hidden href=#bonus-proveriaem-chto-vse-rabotaet>#</a></h3><p>Чтобы проверить, что SSH туннель успешно поднят, можно "пингануть" с вашего компьютера Registry на роботе:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>curl -Is</span><span style=color:#abb2bf> http://localhost:5000/v2/
</span></code></pre><p>Что выведет curl в случае успешного поднятия туннеля:<pre style=background:#2b303b;color:#6c7079><code><span style=color:#abb2bf>HTTP/1.1 200 OK
</span><span style=color:#abb2bf>Content-Length: 2
</span><span style=color:#abb2bf>Content-Type: application/json; charset=utf-8
</span><span style=color:#abb2bf>Docker-Distribution-Api-Version: registry/2.0
</span><span style=color:#abb2bf>X-Content-Type-Options: nosniff
</span><span style=color:#abb2bf>Date: Mon, 04 Sep 2023 20:02:21 GMT
</span></code></pre><p>Если делать этот запрос в цикле, можно дождаться установки соединения и только потом продолжать деплой.<h2 id=shag-4-pushim-obraz-v-docker-registry-na-robote>Шаг 4: Пушим образ в Docker Registry на роботе<a aria-hidden=true class=anchor hidden href=#shag-4-pushim-obraz-v-docker-registry-na-robote>#</a></h2><p>Приступаем к передаче образа на робота. Для этого используем ту же самую команду, что и для билда, но с двумя модификациями:<ol><li><code>--output type=registry</code>.<li><code>--tag host.docker.internal:5000/eurobot2023:latest</code>.</ol><pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>docker</span><span style=color:#abb2bf> buildx build \
</span><span style=color:#eb6772>    --platform</span><span style=color:#abb2bf> linux/amd64 \
</span><span style=color:#eb6772>    --tag</span><span style=color:#abb2bf> host.docker.internal:5000/eurobot2023:latest \
</span><span style=color:#eb6772>    --output</span><span style=color:#abb2bf> type=registry \
</span><span style=color:#abb2bf>    .
</span></code></pre><p>Так как с момента предыдущего билда в <a href=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/#step-1><strong>Шаге 1</strong></a> ничего не изменилось и все слои из докерфайла уже есть в кэше, стадия билда будет пропущена. Начнется загрузка образа в Docker Registry робота.<p>Почему это вообще работает:<ol><li>Опция <code>--output type=registry</code> указывает пушить в Registry после сборки образа.<li>В тег образа мы добавляем префикс <code>host.docker.internal:5000/</code> для того чтобы BuildKit билдер пушил образ в Registry, который доступен из нашей локальной сети. Если указать <code>localhost:5000/</code>, то отправка не заработает, ибо <code>localhost</code> внутри контейнера с билдером ведет в <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">совсем другое место</a>.</ol><p>На самом роботе надо "стянуть" образ из Registry, чтобы он появился в списке при вызове <code>docker images</code> и после этого вернуть ему нормальное имя. Это мы тоже делаем через SSH:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>ssh -o</span><span style=color:#abb2bf> ConnectTimeout=5 \
</span><span style=color:#eb6772>    -o</span><span style=color:#abb2bf> StrictHostKeyChecking=no \
</span><span style=color:#eb6772>    -o</span><span style=color:#abb2bf> UserKnownHostsFile=/dev/null \
</span><span style=color:#abb2bf>    $</span><span style=color:#eb6772>ROBOT_HOSTNAME </span><span style=color:#9acc76>"
</span><span style=color:#9acc76>        docker pull localhost:5000/eurobot2023:latest && \ 
</span><span style=color:#9acc76>        docker tag localhost:5000/eurobot2023:latest eurobot2023:latest
</span><span style=color:#9acc76>    "
</span></code></pre><p>И на этом деплой закончился, образ <code>eurobot2023:latest</code> уже на роботе и готов к запуску.<h2 id=shag-5-chistim-za-soboi>Шаг 5: Чистим за собой<a aria-hidden=true class=anchor hidden href=#shag-5-chistim-za-soboi>#</a></h2><p>Чтобы остановить SSH-туннель, можно просто убить процесс ssh. Для этого ранее мы запоминали его PID в файл <code>SSHPID</code>:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>cat</span><span style=color:#abb2bf> SSHPID </span><span style=color:#adb7c9>| </span><span style=color:#eb6772>xargs</span><span style=color:#abb2bf> kill
</span><span style=color:#eb6772>rm</span><span style=color:#abb2bf> SSHPID </span><span style=font-style:italic;color:#5f697a># не забываем удалить временный файл тоже
</span></code></pre><p>Останавливать Docker Registry на роботе, как я уже писал, смысла большого нет. Дешевле по времени и вычислительным ресурсам просто оставить его работать. Есть еще одна причина не трогать его — если вы работаете в команде и одновременно льете образы на робота, вы можете нечаянно завершить Registry пока кто-то другой передает образ.<h1 id=podvodnye-kamni>Подводные камни<a aria-hidden=true class=anchor hidden href=#podvodnye-kamni>#</a></h1><h2 id=mac-os-specific>Комментарий по поводу Mac OS<a aria-hidden=true class=anchor hidden href=#mac-os-specific>#</a></h2><p>На Mac OS нельзя просто так взять и пробросить SSH-туннель для порта 5000. Все потому что служба AirPlay тоже использует этот порт.<p>Если хотите чтобы описанный здесь код заработал на вашем яблочном компьютере, <a href=https://habr.com/ru/news/591087/>отключите службу AirPlay</a>, либо поменяйте во всех скриптах из этого поста порт 5000 на другой, например на 5001.<h2 id=raskhod-mesta-na-diske>Расход места на диске<a aria-hidden=true class=anchor hidden href=#raskhod-mesta-na-diske>#</a></h2><p>Через какое-то время активной работы у вас на устройстве и на роботе начнут скапливаться груды ненужных слоев от Docker образов. Не забывайте их чистить.</p><center> <p><img alt="Pile Of Docker Containers" src=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/pile-of-containers.jpg></p> <p><em>Извините за картинку из Midjourney, я не удержался</em></p> </center><h2 id=etot-protsess-nuzhdaetsia-v-avtomatizatsii>Этот процесс нуждается в автоматизации<a aria-hidden=true class=anchor hidden href=#etot-protsess-nuzhdaetsia-v-avtomatizatsii>#</a></h2><p>Во время подготовки к соревнованиям мы не запускали все эти шаги руками. Мы пользовались мета билд системой bldr, которая упрощала процесс, скрывая кишки с докером внутри себя.<p>В целом, чтобы автоматизировать все шаги для простого проекта, достаточно и обыкновенных sh скриптов. Если работать в сложном монорепозитории, лучше для подобных затей использовать <a href=https://bazel.build/>Bazel</a>.<h1 id=mysli-naposledok>Мысли напоследок<a aria-hidden=true class=anchor hidden href=#mysli-naposledok>#</a></h1><p>В команде RESET до последнего момента SSH туннель запускался немного иначе — в виде Docker контейнера с утилитой ssh внутри. Это негативно сказывалось на скорости установки и сброса соединения, но зато было удобно останавливать туннель, просто останавливая Docker контейнер. А еще не надо было использовать хак с <code>host.docker.internal</code> для доступа к SSH туннелю внутри Docker сети. Но настраивать такую конфигурацию сложнее, поэтому специально для этого поста я немного допилил нашу реализацию.<blockquote><p>Чем больше я ковырялся c bldr, тем больше хотелось переписать все на Bazel и опубликовать на GitHub. Так любые робототехнические команды могли бы использовать все наработки.</blockquote><p>Деплой по локальной сети сэкономил нам кучу человекочасов во время подготовки к соревнованиям. Но на то чтобы разобраться, как все правильно настроить и автоматизировать, у меня ушло несколько недель. Этот гайд поможет избежать подобных жертв)))</div><footer class=post-footer><ul class=post-tags><li><a href=https://tonykolomeytsev.github.io/tags/docker/>docker</a><li><a href=https://tonykolomeytsev.github.io/tags/ros/>ROS</a><li><a href=https://tonykolomeytsev.github.io/tags/robotics/>robotics</a><li><a href=https://tonykolomeytsev.github.io/tags/eurobot/>eurobot</a><li><a href=https://tonykolomeytsev.github.io/tags/skoltech/>skoltech</a><li><a href=https://tonykolomeytsev.github.io/tags/guide/>guide</a></ul><section class=comments><script async data-color=1d1e20 data-colorful=1 data-comments-limit=5 data-dark=1 data-dark-color=FFFFFF data-telegram-discussion=kekmech/15 id=tg-discussion-widget src=https://telegram.org/js/telegram-widget.js?22></script></section><nav class=paginav><a class=prev href=https://tonykolomeytsev.github.io/posts/eurobot-experience-docker-with-ros/> <span class=title>« Prev</span> <br> <span>Опыт Eurobot: ROS2 вместе с Docker</span> </a><a class=next href=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/> <span class=title>Next »</span> <br> <span>Gradle + GitLab: эффективный и бесплатный билд-кэш</span> </a></nav></footer></article></main><footer class=footer><span>© 2024 <a href=https://tonykolomeytsev.github.io>Anton Kolomeytsev</a></span><span> Powered by <a rel="noopener noreferrer" href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/cydave/zola-theme-papermod rel=noopener target=_blank>PaperMod</a> </span></footer><a aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g class=top-link href=#top id=top-link> <svg viewbox="0 0 12 6" fill=currentColor xmlns=http://www.w3.org/2000/svg><path d="M12 6H0l6-6z"/></svg> </a><script>let menu=document.getElementById('menu');if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}};document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var c=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(c)}']`).scrollIntoView({behavior:"smooth"})}else{document.querySelector(`[id='${decodeURIComponent(c)}']`).scrollIntoView()};if(c==="top"){history.replaceState(null,null," ")}else{history.pushState(null,null,`#${c}`)}})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1"}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0"}}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light')}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark')}})</script><script>document.querySelectorAll('pre > code').forEach(a=>{const c=a.parentNode.parentNode;const d=document.createElement('button');d.classList.add('copy-code');d.innerText='copy';function b(){d.innerText='copied!';setTimeout(()=>{d.innerText='copy'},2000)}d.addEventListener('click',e=>{if('clipboard' in navigator){navigator.clipboard.writeText(a.textContent);b();return};const f=document.createRange();f.selectNodeContents(a);const g=window.getSelection();g.removeAllRanges();g.addRange(f);try{document.execCommand('copy');b()}catch(h){};g.removeRange(f)});if(c.classList.contains("highlight")){c.appendChild(d)}else if(c.parentNode.firstChild==c){}else if(a.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){a.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(d)}else{a.parentNode.appendChild(d)}})</script>