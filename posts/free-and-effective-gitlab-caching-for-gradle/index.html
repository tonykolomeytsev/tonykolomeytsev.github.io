<!doctype html><html dir=auto lang=en><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="index, follow" name=robots><meta content=mmSUCWwptqJJuCzIwQO7JyFJ4dbxkrHO92nV7PBwRIg name=google-site-verification><title>Gradle + GitLab: эффективный и бесплатный билд-кэш</title><meta content="android, development, tech, robotics" name=keywords><meta name=description><meta content="Anton Kolomeytsev" name=author><link href=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/ rel=canonical><link href=https://tonykolomeytsev.github.io/css/includes/scroll-bar.css rel=stylesheet><link href=https://tonykolomeytsev.github.io/css/styles.css rel=stylesheet><link href=https://tonykolomeytsev.github.io/css/override.css rel=stylesheet><link href=https://tonykolomeytsev.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><noscript><style>#theme-toggle,.top-link{display:none}</style> <style>@media (prefers-color-scheme:dark){:root {--theme:#1d1e20;--entry:#2e2e33;--primary:#dadadb;--secondary:#9b9c9d;--tertiary:#414244;--content:#c4c4c5;--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark):-webkit-scrollbar-track {background:0 0}.list:not(.dark):-webkit-scrollbar-thumb {border:var(--theme)}}</style></noscript><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark')}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark')}</script><header class=header><nav class=nav><div class=logo><a title="Kekmech (Alt + H)" accesskey=h href=https://tonykolomeytsev.github.io> Kekmech </a><div class=logo-switches><button title="(Alt + T)" accesskey=t id=theme-toggle><svg viewbox="0 0 24 24" fill=none height=18 id=moon stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> <svg viewbox="0 0 24 24" fill=none height=18 id=sun stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></button><ul class=lang-switch><li></ul></div></div><ul id=menu><li><a href=https://tonykolomeytsev.github.io/archive title=Archive> <span>Archive</span> </a><li><a href=https://tonykolomeytsev.github.io/tags title=Tags> <span>Tags</span> </a></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tonykolomeytsev.github.io>Home</a> »  <a href=https://tonykolomeytsev.github.io/posts/>Posts</a> »  <a href=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/>Gradle + GitLab: эффективный и бесплатный билд-кэш</a></div><h1 class=post-title>Gradle + GitLab: эффективный и бесплатный билд-кэш</h1><div class=post-meta><span title="2024-07-27 00:00:00 +0000">2024-07-27</span> · 17 min · 3271 words · Anton Kolomeytsev  | <a rel="noopener noreferrer" href=https://github.com/tonykolomeytsev/tonykolomeytsev.github.io/tree/master/content/posts/2024-03-10_free-and-effective-gitlab-caching-for-gradle/index.md target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary title="(Alt + C)" accesskey=c><span class=details>Table of Contents</span></summary> <div class=inner><ul><li><a aria-label=Контекст href=#kontekst>Контекст</a><li><a aria-label=Проблема href=#problema>Проблема</a><li><a aria-label=Решение href=#reshenie>Решение</a> <ul><li><a aria-label="Проверяем что базовые вещи сделаны правильно" href=#proveriaem-chto-bazovye-veshchi-sdelany-pravil-no>Проверяем что базовые вещи сделаны правильно</a> <ul><li><a aria-label="Разделение пайплайнов по предназначению" href=#razdelenie-paiplainov-po-prednaznacheniiu>Разделение пайплайнов по предназначению</a><li><a aria-label="Разделение GitLab кэшей по предназначению" href=#razdelenie-gitlab-keshei-po-prednaznacheniiu>Разделение GitLab кэшей по предназначению</a><li><a aria-label="Отдельный GitLab кэш для Gradle Wrapper" href=#otdel-nyi-gitlab-kesh-dlia-gradle-wrapper>Отдельный GitLab кэш для Gradle Wrapper</a><li><a aria-label="Отдельный GitLab кэш для зависимостей" href=#otdel-nyi-gitlab-kesh-dlia-zavisimostei>Отдельный GitLab кэш для зависимостей</a><li><a aria-label="Отдельный GitLab кэш для Gradle build cache" href=#otdel-nyi-gitlab-kesh-dlia-gradle-build-cache>Отдельный GitLab кэш для Gradle build cache</a><li><a aria-label="Собираем все вместе" href=#sobiraem-vse-vmeste>Собираем все вместе</a><li><a aria-label="Упс, купите Gradle Enterprise" href=#ups-kupite-gradle-enterprise>Упс, купите Gradle Enterprise</a></ul><li><a aria-label="Вытаскиваем кэш-ключи" href=#vytaskivaem-kesh-kliuchi>Вытаскиваем кэш-ключи</a> <ul><li><a aria-label="Пишем BuildService" href=#pishem-buildservice>Пишем BuildService</a></ul><li><a aria-label="Докручиваем базовое решение" href=#dokruchivaem-bazovoe-reshenie>Докручиваем базовое решение</a> <ul><li><a aria-label="Переиспользуем билд кэш для генерации нового кэша" href=#pereispol-zuem-bild-kesh-dlia-generatsii-novogo-kesha>Переиспользуем билд кэш для генерации нового кэша</a><li><a aria-label="Переиспользуем билд кэш MR-ов в пайплайнах MR-ов" href=#pereispol-zuem-bild-kesh-mr-ov-v-paiplainakh-mr-ov>Переиспользуем билд кэш MR-ов в пайплайнах MR-ов</a></ul><li><a aria-label="Как это дебажить?" href=#kak-eto-debazhit>Как это дебажить?</a></ul><li><a aria-label=Итоги href=#itogi>Итоги</a> <ul><li><a aria-label="Какие есть минусы у решения и что можно доработать?" href=#kakie-est-minusy-u-resheniia-i-chto-mozhno-dorabotat>Какие есть минусы у решения и что можно доработать?</a> <ul><li><a aria-label="Не реализована очистка кэша зависимостей" href=#ne-realizovana-ochistka-kesha-zavisimostei>Не реализована очистка кэша зависимостей</a><li><a aria-label="Последовательные запуски gradle ломают логику" href=#posledovatel-nye-zapuski-gradle-lomaiut-logiku>Последовательные запуски gradle ломают логику</a><li><a aria-label="Накапливаем список всех ключей в оперативной памяти" href=#nakaplivaem-spisok-vsekh-kliuchei-v-operativnoi-pamiati>Накапливаем список всех ключей в оперативной памяти</a><li><a aria-label=Сложна href=#slozhna>Сложна</a></ul><li><a aria-label="О хорошем" href=#o-khoroshem>О хорошем</a></ul></ul></div></details></div><div class=post-content><h1 id=kontekst>Контекст<a aria-hidden=true class=anchor hidden href=#kontekst>#</a></h1><p>Эта заметка является чем-то вроде гайда по бюджетной настройке GitLab кэшей для Gradle в Android проектах без использования Gradle Enterprise и Remote Build Cache. В интернете маловато текстовых материалов о том, как настраивать кэши Gradle на CI, и еще меньше о том, как это делать правильно. В придачу, когда кто-то задает правильные вопросы в Gradle Slack, на форуме Gradle или на StackOverflow, прибегают увлажняемые из Gradle и рекомендуют не копать в нужную сторону, а просто купить Gradle Enterprise (или как он там щас называется).<p>У меня есть опыт выстраивания билд-инфраструктуры в большом коммерческом Android-проекте. И я хочу поделиться лайфхаками с теми, кто только начинает заниматься оптимизациями билда на CI в своем проекте.<h1 id=problema>Проблема<a aria-hidden=true class=anchor hidden href=#problema>#</a></h1><blockquote><p>Проблема в том, что Gradle говно <br> — Джейсон Стэтхэм</blockquote><p>Каждый уважающий себя проект имеет хотя бы простейшую систему CI/CD, чаще всего в GitLab. С ростом проекта увеличивается и время ожидания прогонов сборок/тестов/линтера и т.д. В какой-то момент время ожидания проверки вашего МР переваливает за все допустимые границы и приходит желание что-то с этим делать.<h1 id=reshenie>Решение<a aria-hidden=true class=anchor hidden href=#reshenie>#</a></h1><p>Предлагаемое мною решение работает на проектах величиной до 500 модулей. Если у вас модулей больше, скорее всего вы знаете лучше меня как оптимизировать билды.<p>Говоря "500 модулей" я имею ввиду 500 модулей из <a href="https://www.youtube.com/watch?v=oAQlKiF91Ks">замечательного доклада Степана Гончарова</a>.<h2 id=proveriaem-chto-bazovye-veshchi-sdelany-pravil-no>Проверяем что базовые вещи сделаны правильно<a aria-hidden=true class=anchor hidden href=#proveriaem-chto-bazovye-veshchi-sdelany-pravil-no>#</a></h2><h3 id=razdelenie-paiplainov-po-prednaznacheniiu>Разделение пайплайнов по предназначению<a aria-hidden=true class=anchor hidden href=#razdelenie-paiplainov-po-prednaznacheniiu>#</a></h3><blockquote><p>Генерируйте кэш в одних пайплайнах, используйте его в других.</blockquote><p>В первую очередь надо понять, что загрузка и сохранение кэша в GitLab, это не бесплатный по времени процесс. Чем больше весит кэш, тем дольше он упаковывается в архив и отгружается в облако. Даже Gradle Remote Build Cache не бесплатная штука, особенно если вы используете стандартный Remote Build Cache плагин и официальную Docker ноду. Поэтому в базовой реализации не все пайплайны должны генерировать кэш.<p>Предлагаемая мною схема такая:<ul><li>У проекта есть основная ветка, пусть она называется <code>master</code>.<li>Есть <code>feature</code>-ветки, которые в конце своей жизни вливаются в <code>master</code>.<li>При вливании в <code>master</code> запускается пайп, генерирующей билд кэш. Если не хочется запускать при вливании, запускаем по расписанию.<li>Когда запускаются пайплайны на <code>feature</code>-ветках, они используют кэш сгенерированный на ветке <code>master</code>.</ul><p><img alt="Different pipeline purposes" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/different-pipeline-purposes.png><h3 id=razdelenie-gitlab-keshei-po-prednaznacheniiu>Разделение GitLab кэшей по предназначению<a aria-hidden=true class=anchor hidden href=#razdelenie-gitlab-keshei-po-prednaznacheniiu>#</a></h3><blockquote><p>Кэшировать билд-кэш, зависимости и Gradle Wrapper нужно отдельными ключами</blockquote><p>В проекте чаще всего меняется код продукта, немного реже меняются зависимости, и еще реже меняется версия Gradle. Я считаю что кэш для этих сущностей должен быть отдельный. Суммарный вес архива с общим кэшом быстро превысит допустимые для отгрузки по s3 лимиты. К тому же джобы, которым нужны не все виды кэша, будут выполнятся быстрее если не будут грузить ничего лишнего.<p><img alt="Different types of Gradle cache" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/different-types-of-gradle-cache.png><p>Все что надо кэшировать на CI, Gradle хранит в директории <code>$GRADLE_USER_HOME</code>. Вы можете переопределить эту переменную окружения для джоб:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>some job</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>variables</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>GRADLE_USER_HOME</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PROJECT_DIR/.gradle
</span></code></pre><p>Далее во всех примерах я буду считать что <code>$GRADLE_USER_HOME</code> именно такой.<pre class=language-shell data-lang=shell style=background:#2b303b;color:#6c7079><code class=language-shell data-lang=shell><span style=color:#abb2bf>$GRADLE_USER_HOME/
</span><span style=color:#abb2bf>├── caches/
</span><span style=color:#abb2bf>│   ├── build-cache-1/ &LT- Билд-кэш
</span><span style=color:#abb2bf>│   └── modules-2/ &LT- кэш зависимостей
</span><span style=color:#abb2bf>├── notifications/ &LT- мусор для wrapper
</span><span style=color:#abb2bf>└── wrapper/ &LT- дистрибутивы wrapper
</span></code></pre><h3 id=otdel-nyi-gitlab-kesh-dlia-gradle-wrapper>Отдельный GitLab кэш для Gradle Wrapper<a aria-hidden=true class=anchor hidden href=#otdel-nyi-gitlab-kesh-dlia-gradle-wrapper>#</a></h3><p>Дистрибутивы Gradle хранятся в <code>$GRADLE_USER_HOME/wrapper/</code>, а дополнительный мусор от него хранится в <code>$GRADLE_USER_HOME/notifications/</code>. Хорошо бы для этих сущностей выделить отдельные GitLab cache key:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=font-style:italic;color:#5f697a># cache.yml
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.pull-wrapper-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-wrapper
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/wrapper/
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/notifications/
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.pull-push-wrapper-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-wrapper
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull-push
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/wrapper/
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/notifications/
</span></code></pre><p>Тогда в джобах, которые генерируют билд-кэш, мы можем указывать:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>cache build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-push-wrapper-cache </span><span style=color:#abb2bf>]
</span></code></pre><p>В документации Gradle сказано что неиспользуемые версии дистрибутивов удаляются автоматически через какое-то время. Поверим им на слово. Кэш с дистрибутивами не должен разрастаться слишком сильно.<p>В джобах, которые только потребляют билд-кэш, можно указывать:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>lint</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-wrapper-cache </span><span style=color:#abb2bf>]
</span></code></pre><p>Дистрибутивы Gradle не весят много, поэтому архивы с ними будут загружаться в джобу быстро.<h3 id=otdel-nyi-gitlab-kesh-dlia-zavisimostei>Отдельный GitLab кэш для зависимостей<a aria-hidden=true class=anchor hidden href=#otdel-nyi-gitlab-kesh-dlia-zavisimostei>#</a></h3><p>Зависимости это AAR и JAR артефакты всех либ и плагинов используемых в проекте. Gradle их хранит в <code>$GRADLE_USER_HOME/caches/modules-2/</code>. Выделяем расширения для работы с кэшами зависимостей:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=font-style:italic;color:#5f697a># cache.yml
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.pull-deps-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-deps
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/modules-2/
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.push-deps-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-deps
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>push
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/modules-2/
</span></code></pre><p>Тогда в джобах, которые генерируют билд-кэш, мы можем указывать:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>cache build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-deps-cache </span><span style=color:#abb2bf>]
</span></code></pre><p>Как можно заметить, джоба для генерации кэша вообще не получает зависимостей при старте и всегда качает их заново. Объясняю это дальше.<p>В джобах, которые только потребляют билд-кэш, можно указывать:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>lint</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-deps-cache </span><span style=color:#abb2bf>]
</span></code></pre><p>Зависимости проекта весят больше, чем дистрибутивы, но меньше чем билд кэш.<h3 id=otdel-nyi-gitlab-kesh-dlia-gradle-build-cache>Отдельный GitLab кэш для Gradle build cache<a aria-hidden=true class=anchor hidden href=#otdel-nyi-gitlab-kesh-dlia-gradle-build-cache>#</a></h3><p>Самая тяжелая часть кэша — билд-кэш.<p>Билд-кэш хранится в <code>$GRADLE_USER_HOME/caches/build-cache-1/</code>. Вложенных директорий внутри нет, там просто огромная простыня с бинарными файлами. Создаем расширения для работы с билд-кэшом:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=font-style:italic;color:#5f697a># cache.yml
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.pull-build-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-build
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/build-cache-1/
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.push-build-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-build
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>push
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/build-cache-1/
</span></code></pre><p>Джоба генерации кэша выглядит вот так:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>cache build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-build-cache </span><span style=color:#abb2bf>]
</span></code></pre><p>И снова джоба для генерации кэша предыдущую версию кэша не получает. Объясняю это дальше.<p>Джобы потребляющие билд кэш получают вот такую запись:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>test</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-build-cache </span><span style=color:#abb2bf>]
</span></code></pre><h3 id=sobiraem-vse-vmeste>Собираем все вместе<a aria-hidden=true class=anchor hidden href=#sobiraem-vse-vmeste>#</a></h3><p>Если собрать все воедино, то может получиться что-то такое:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>.base</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>variables</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>GRADLE_USER_HOME</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PROJECT_DIR/.gradle
</span><span style=color:#abb2bf>  </span><span style=font-style:italic;color:#5f697a># Тут какие-то еще базовые настройки, которые я пропустил
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>before_script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>after_script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Эта джоба запускается в МРе
</span><span style=color:#eb6772>build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>stage</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>check
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>extends</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>.base
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>./gradlew :app:assembleDebug
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-wrapper-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-deps-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-build-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>rules</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#eb6772>if</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PIPELINE_SOURCE = "merge_request_event"
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Эта джоба запускается после вливания МРа
</span><span style=color:#eb6772>cache build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>stage</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>post-check
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>extends</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>.base
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>./gradlew :app:assembleDebug
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-push-wrapper-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-deps-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-build-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>rules</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#eb6772>if</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PIPELINE_SOURCE = "push" && $CI_COMMIT_BRANCH == "master"
</span></code></pre><p>На данном этапе сборка в прогонах МРа будет уже заметно ускорена. Но как любят говорить соевые айтишники, "тут есть точки роста".<p><img alt="Build cache isn't reused" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/build-cache-isnt-reused.png><p>Джобе cache build не дается кэш от ее предыдущих запусков. То есть билд и закачка зависимостей в этой джобе происходит каждый раз с нуля. Все потому что Gradle самостоятельно не очищает неиспользуемый кэш и зависимости. Если для генерации нового кэша мы будем использовать результаты прошлых прогонов, то кэш будет разрастаться с огромной скоростью. Он быстро перевалит за критическую отметку в 5 гигабайт, после чего вы даже не сможете загрузить его в хранилище s3. Короче, это просто такой способ защититься от неконтролируемого роста GitLab кэша.<p>Полное отсутствие билд-кэша приводит к долгим прогонам. Настолько долгим, что стоит задуматься, а целесообразно ли генерить кэш при каждом вливании в master, или все-таки лучше делать это по расписанию?<p>Если бы мы только могли сами очищать ненужные cache entry в директории <code>$GRADLE_USER_HOME/caches/build-cache-1/</code>, было бы супер удобно, мммм?<h3 id=ups-kupite-gradle-enterprise>Упс, купите Gradle Enterprise<a aria-hidden=true class=anchor hidden href=#ups-kupite-gradle-enterprise>#</a></h3><p>Нужный нам функционал уже есть в Gradle Enterprise, но за него у вас могут попросить деняк. А если вы работаете в Богом хранимой, то вас еще могут попросить пойти нахуй. Вручную посмотреть использованные кэш-ключи Gradle можно при помощи опции <code>--scan</code>. Но автоматизировать сбор и парсинг этих данных на CI проблематично. Про то как сломать Gradle Enterprise плагин и заставить его делиться билд сканами я напишу отдельную заметку. Для текущей заметки нашел более простой способ решить проблему.</p><center> <p><img alt="Pepe meme" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/pepe-meme.png></p> </center><p>Бизнес-модель Gradle построена на ненависти к людям, мы такое осуждаем, поэтому деняк им не дадим. Давайте без Enterprise версии будем вытаскивать кэш-ключи от билдов на CI.<h2 id=vytaskivaem-kesh-kliuchi>Вытаскиваем кэш-ключи<a aria-hidden=true class=anchor hidden href=#vytaskivaem-kesh-kliuchi>#</a></h2><p>Для того чтобы получить доступ к кэш-ключам, нам придется использовать gradle internal api. Хорошее объяснение того, что мы дальше делаем, есть в <a href="https://mobiusconf.com/en/archive/2024%20Spring/talks/f9f7e56446a7462eb8e3e4ba6cc64770/?referer=%2Fen%2Farchive%2F2024%2520Spring%2Fpartners%2F42a2ee1c-85c9-4ceb-ba77-a0fe87f91cec%2F">докладе от Тинькофф на Mobius Spring 2024</a>.<h3 id=pishem-buildservice>Пишем BuildService<a aria-hidden=true class=anchor hidden href=#pishem-buildservice>#</a></h3><p>Реализуем свой сервис, который подписывается на все билд-операции и в конце билда выгружает список кэш-ключей в файл:<pre class=language-kotlin data-lang=kotlin style=background:#2b303b;color:#6c7079><code class=language-kotlin data-lang=kotlin><span style=color:#cd74e8>internal abstract class </span><span style=color:#f0c678>CacheKeysHandlerService </span><span style=color:#adb7c9>:
</span><span style=color:#abb2bf>    BuildService&LTCacheKeysHandlerService</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>Params>,
</span><span style=color:#abb2bf>    BuildOperationListener,
</span><span style=color:#abb2bf>    AutoCloseable {
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>interface </span><span style=color:#f0c678>Params </span><span style=color:#adb7c9>: </span><span style=color:#9acc76>BuildServiceParameters</span><span style=color:#abb2bf> {
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>val </span><span style=color:#abb2bf>cacheKeysFile</span><span style=color:#adb7c9>:</span><span style=color:#abb2bf> RegularFileProperty
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>private val </span><span style=color:#abb2bf>cacheKeys</span><span style=color:#adb7c9>: </span><span style=color:#cd74e8>MutableSet</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>String</span><span style=color:#abb2bf>> </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> ConcurrentHashMap</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>newKeySet()
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>started</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>descriptor:</span><span style=color:#abb2bf> BuildOperationDescriptor, </span><span style=color:#adb7c9>event:</span><span style=color:#abb2bf> OperationStartEvent) {
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>/* no-op */
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>progress</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>identifier:</span><span style=color:#abb2bf> OperationIdentifier, </span><span style=color:#adb7c9>event:</span><span style=color:#abb2bf> OperationProgressEvent) {
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>/* no-op */
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>finished</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>descriptor:</span><span style=color:#abb2bf> BuildOperationDescriptor, </span><span style=color:#adb7c9>event:</span><span style=color:#abb2bf> OperationFinishEvent) {
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>when</span><span style=color:#abb2bf> (</span><span style=color:#cd74e8>val</span><span style=color:#abb2bf> details </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> descriptor</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>details) {
</span><span style=color:#abb2bf>            </span><span style=font-style:italic;color:#5f697a>// cохранение в кэш (локальный и remote)
</span><span style=color:#abb2bf>            </span><span style=color:#adb7c9>is</span><span style=color:#abb2bf> StoreOperationDetails </span><span style=color:#adb7c9>-></span><span style=color:#abb2bf> cacheKeys </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> details</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKey
</span><span style=color:#abb2bf>            </span><span style=font-style:italic;color:#5f697a>// загрузка из кэша (локального и remote)
</span><span style=color:#abb2bf>            </span><span style=color:#adb7c9>is</span><span style=color:#abb2bf> LoadOperationDetails </span><span style=color:#adb7c9>-></span><span style=color:#abb2bf> cacheKeys </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> details</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKey
</span><span style=color:#abb2bf>            </span><span style=font-style:italic;color:#5f697a>// сериализация кэша
</span><span style=color:#abb2bf>            </span><span style=color:#adb7c9>is</span><span style=color:#abb2bf> PackOperationDetails </span><span style=color:#adb7c9>-></span><span style=color:#abb2bf> cacheKeys </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> details</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKey
</span><span style=color:#abb2bf>            </span><span style=font-style:italic;color:#5f697a>// десериализация кэша
</span><span style=color:#abb2bf>            </span><span style=color:#adb7c9>is</span><span style=color:#abb2bf> UnpackOperationDetails </span><span style=color:#adb7c9>-></span><span style=color:#abb2bf> cacheKeys </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> details</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKey
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>close</span><span style=color:#abb2bf>() {
</span><span style=color:#abb2bf>        parameters</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKeysFile</span><span style=color:#adb7c9>.</span><span style=color:#5cb3fa>get</span><span style=color:#abb2bf>().asFile.bufferedWriter().use { writer </span><span style=color:#adb7c9>->
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> (key </span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> cacheKeys) {
</span><span style=color:#abb2bf>                writer</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>appendLine(key)
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>}
</span></code></pre><p>Объясняю что происходит:<ol><li>Все сервисы Gradle работающие на фоне во время билда должны реализовывать интерфейс <code>BuildService<*></code>. Интерфейс <code>Params</code> является "внешним API" для нашего сервиса.<li><code>BuildOperationListener</code> мы реализуем для того чтобы подписаться на все билд-операции Gradle. Это интерфейс из пакета <code>internal</code>. К сожалению аналогичный "listener" из публичного API не дает возможности посмотреть на кэш-ключи.<li>Интерфейс <code>AutoCloseable</code> для того чтобы реализовать метод <code>close()</code>. Он вызовется в конце билда. Именно там мы должны будем обработать собранные за все время билда данные.<li>Поле <code>cacheKeys: MutableSet&LTString></code>. Тут аккумулируем кэш-ключи. Важно что <code>BuildOperationListener</code> не является потокобезопасным, нам нельзя блочить его работу, и нужно самостоятельно обрабатывать многопоточный вызов его методов. Поэтому для реализации <code>cacheKeys</code> используем коллекцию из <code>java.util.concurrent</code>.<li>Из всех методов колбека <code>BuildOperationListener</code> нам нужно реализовать только <code>finished</code>. В него прилетают интересующие нас события, в том числе события обработки кэш-ключей. Кэш-ключи могут повторяться, поэтому у нас Set. Мониторим все возможные события для надежности.</ol><p>Подключаем созданный нами сервис при помощи convention-плагина:<pre class=language-kotlin data-lang=kotlin style=background:#2b303b;color:#6c7079><code class=language-kotlin data-lang=kotlin><span style=color:#abb2bf>@Suppress(</span><span style=color:#9acc76>"unused"</span><span style=color:#abb2bf>, </span><span style=color:#9acc76>"UnstableApiUsage"</span><span style=color:#abb2bf>)
</span><span style=color:#cd74e8>internal abstract class </span><span style=color:#f0c678>CacheKeysHandlerPlugin</span><span style=color:#abb2bf> @</span><span style=color:#f0c678>Inject constructor</span><span style=color:#abb2bf>(
</span><span style=color:#abb2bf>    </span><span style=color:#adb7c9>providers:</span><span style=color:#abb2bf> ProviderFactory,
</span><span style=color:#abb2bf>    </span><span style=color:#adb7c9>layout:</span><span style=color:#abb2bf> BuildLayout,
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>private val </span><span style=color:#adb7c9>registryInternal:</span><span style=color:#abb2bf> BuildEventListenerRegistryInternal,
</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>: </span><span style=color:#9acc76>Plugin</span><span style=color:#abb2bf><</span><span style=color:#9acc76>Settings</span><span style=color:#abb2bf>> {
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=font-style:italic;color:#5f697a>/** По-умолчанию плагин выключен, врубаем его только на CI */
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>private val </span><span style=color:#abb2bf>enabled </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> providers
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>gradleProperty(</span><span style=color:#9acc76>"com.example.build.cache-keys.enabled"</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>map { it</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>toBoolean() }
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>getOrElse(</span><span style=color:#db9d63>false</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=font-style:italic;color:#5f697a>/** Можем указать кастомный путь до output-файла с кэш-ключами */
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>private val </span><span style=color:#abb2bf>cacheKeysFile </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> providers
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>gradleProperty(</span><span style=color:#9acc76>"com.example.build.cache-keys.file-name"</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>orElse(</span><span style=color:#9acc76>"cache-keys.txt"</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// Когда мы указываем путь через layout, а не через java.io.File,
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// Gradle сам создает файл на старте билда.
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>map { layout</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>rootDirectory</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>file(it) }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>apply</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>target:</span><span style=color:#abb2bf> Settings)</span><span style=color:#adb7c9>: </span><span style=color:#cd74e8>Unit </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> with(target) {
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> (</span><span style=color:#adb7c9>!</span><span style=color:#abb2bf>enabled) </span><span style=color:#cd74e8>return
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>val </span><span style=color:#abb2bf>serviceProvider </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> gradle</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>sharedServices</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>registerIfAbsent(
</span><span style=color:#abb2bf>            </span><span style=color:#9acc76>"cache-keys-handler-service"</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>            CacheKeysHandlerService</span><span style=color:#adb7c9>::</span><span style=color:#abb2bf>class</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>java,
</span><span style=color:#abb2bf>        ) { spec </span><span style=color:#adb7c9>->
</span><span style=color:#abb2bf>            with(spec) {
</span><span style=color:#abb2bf>                parameters</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKeysFile</span><span style=color:#adb7c9>.</span><span style=color:#5cb3fa>set</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>cacheKeysFile</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>        registryInternal</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>onOperationCompletion(serviceProvider)
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>}
</span></code></pre><blockquote><p>Список того что можно инжектить в конструкторы плагинов и сервисов: <a href=https://docs.gradle.org/current/userguide/service_injection.html>Understanding Services and Service Injection</a>.</blockquote><p>Подключаем этот convention-плагин в <code>settings.gradle</code> файле вашего проекта. На этом собственно самая сложная часть закончилась.<blockquote><p>Важно заметить, что этот способ на 100% работает только при выполнении двух условий:<ol><li>Когда нет тасок UP-TO-DATE. Потому что если таска UP-TO-DATE, Gradle не использует механизм build caching и отследить кэш-ключи становится на порядок сложнее.<li>Когда отключен Configuration Cache.</ol><p>На CI в чистых контейнерах такой проблемы нет и configuration cache там отключен (отключен же, да?).<p>Локально при тестировании функционала это надо учитывать. Перед тестами вызывать <code>./gradlew clean</code>, чтобы удалить <code>build</code> директории во всех модулях, а также использовать аргумент <code>--no-configuration-cache</code>. Подробнее про <a href=https://stackoverflow.com/questions/65101472/what-is-the-difference-between-from-cache-and-up-to-date-in-gradle>отличия UP-TO-DATE и FROM-CACHE</a>.</blockquote><h2 id=dokruchivaem-bazovoe-reshenie>Докручиваем базовое решение<a aria-hidden=true class=anchor hidden href=#dokruchivaem-bazovoe-reshenie>#</a></h2><h3 id=pereispol-zuem-bild-kesh-dlia-generatsii-novogo-kesha>Переиспользуем билд кэш для генерации нового кэша<a aria-hidden=true class=anchor hidden href=#pereispol-zuem-bild-kesh-dlia-generatsii-novogo-kesha>#</a></h3><p>Так как мы теперь знаем, какие кэш-ключики были использованы во время билда, мы можем спокойно дропать все остальные. Так мы в разы ускоряем прогон пайплайна для генерации кэша:<p><img alt="Intersection between old and new cache key sets" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/old-new-cache-intersection.png><p>На картинке все выглядит красиво, осталось это реализовать. Давайте допилим наш <code>CacheKeysHandlerService</code> функцией удаления неиспользованного билд-кэша:<pre class=language-kotlin data-lang=kotlin style=background:#2b303b;color:#6c7079><code class=language-kotlin data-lang=kotlin><span style=color:#cd74e8>internal abstract class </span><span style=color:#f0c678>CacheKeysHandlerService</span><span style=color:#abb2bf> @</span><span style=color:#f0c678>Inject constructor</span><span style=color:#abb2bf>(
</span><span style=color:#abb2bf>    </span><span style=color:#adb7c9>gradle:</span><span style=color:#abb2bf> Gradle, </span><span style=color:#adb7c9>// это тоже добавляем
</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>:
</span><span style=color:#abb2bf>    BuildService&LTCacheKeysHandlerService</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>Params>,
</span><span style=color:#abb2bf>    BuildOperationListener,
</span><span style=color:#abb2bf>    AutoCloseable {
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=font-style:italic;color:#5f697a>// написанный ранее код...
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>private val </span><span style=color:#abb2bf>buildCacheDir</span><span style=color:#adb7c9>:</span><span style=color:#abb2bf> File </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> checkNotNull(gradle</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>gradleHomeDir)
</span><span style=color:#abb2bf>        </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>resolve(</span><span style=color:#9acc76>"caches/build-cache-1"</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>close</span><span style=color:#abb2bf>() {
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// написанный ранее код...
</span><span style=color:#abb2bf>        
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// Удаляем все кэш-ключи, не вошедшие в текущий билд
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>val </span><span style=color:#abb2bf>unusedCacheKeys </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> iterateBuildCache { it </span><span style=color:#adb7c9>!</span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> cacheKeys }
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> (key </span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> unusedCacheKeys) {
</span><span style=color:#abb2bf>            check(buildCacheDir</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>resolve(key)</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>delete()) {
</span><span style=color:#abb2bf>                </span><span style=color:#9acc76>"Unable to delete cache key file: </span><span style=color:#eb6772>$key</span><span style=color:#9acc76>"
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>private fun </span><span style=color:#5cb3fa>iterateBuildCache</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>selector:</span><span style=color:#abb2bf> (</span><span style=color:#cd74e8>String</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>-> </span><span style=color:#cd74e8>Boolean</span><span style=color:#abb2bf>)</span><span style=color:#adb7c9>: </span><span style=color:#cd74e8>Array</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>out</span><span style=color:#abb2bf> File> </span><span style=color:#adb7c9>=
</span><span style=color:#abb2bf>        buildCacheDir
</span><span style=color:#abb2bf>            </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>listFiles { file </span><span style=color:#adb7c9>-></span><span style=color:#abb2bf> selector(file</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>name) }
</span><span style=color:#abb2bf>            </span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>orEmpty()
</span><span style=color:#abb2bf>}
</span></code></pre><p>Теперь мы можем немного поправить наш GitLab Yaml конфиг. Во-первых, добавить новый конфиг для кэша:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=font-style:italic;color:#5f697a># cache.yml
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.pull-push-build-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-build
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull-push
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/build-cache-1/
</span></code></pre><p>Во-вторых использовать этот конфиг в джобе генерации кэша:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#abb2bf>...
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Эта джоба запускается после вливания МРа
</span><span style=color:#eb6772>cache build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>stage</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>post-check
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>extends</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>.base
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>./gradlew :app:assembleDebug
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-push-wrapper-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-deps-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-push-build-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>rules</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#eb6772>if</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PIPELINE_SOURCE = "push" && $CI_COMMIT_BRANCH == "master"
</span></code></pre><p>Теперь можно не бояться обновлять кэш при каждом вливании в <code>master</code>, ибо это будет происходить быстро. Чем чаще обновляем кэш, тем выше cache-hit в пайплайнах наших МРов. При условии что мы не забываем периодически их ребейзить и держать up-to-date с главной веткой.<h4 id=a-mozhno-li-tak-zhe-s-keshom-zavisimostei>А можно ли так же с кэшом зависимостей?<a aria-hidden=true class=anchor hidden href=#a-mozhno-li-tak-zhe-s-keshom-zavisimostei>#</a></h4><p>Да можно, но это тема отдельной текстовой карточки. Есть лайфкек, называется "Перчатка Таноса". Работает следующим образом: используем <code>policy: pull-push</code> для GitLab кэша зависимостей; при этом на старте джобы удаляем 50% рандомных пакетов в <code>$GRADLE_USER_HOME/caches/modules-2/</code>. Отлично работающий на практике способ.</p><center> <p><img alt="Thanos Pepe meme" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/thanos-pepe-meme.jpeg></p> </center><h3 id=pereispol-zuem-bild-kesh-mr-ov-v-paiplainakh-mr-ov>Переиспользуем билд кэш MR-ов в пайплайнах MR-ов<a aria-hidden=true class=anchor hidden href=#pereispol-zuem-bild-kesh-mr-ov-v-paiplainakh-mr-ov>#</a></h3><blockquote><p>Это уже задача со звездочкой.</blockquote><p>Можно еще сильнее ускорить прогон пайплайнов в МРах, если переиспользовать в каждом новом прогоне кэш, сгенерированный в предыдущем. Для этого мы должны передавать между джобами как можно меньше данных. На скачивание и отгрузку кэша не должно уходить больше времени, чем на полезную работу внутри джобы.<p><img alt="Branch specific cache keys set" src=https://tonykolomeytsev.github.io/posts/free-and-effective-gitlab-caching-for-gradle/branch-specific-key-set.png><p>Грубо говоря, после каждого прогона джобы на МРе мы должны:<ol><li>Удалить все кэш-ключи, которые <strong>ЕСТЬ</strong> в ветке master. Потому что в следующий раз мы снова их спокойно подтянем из master.<li>Удалить все кэш-ключи, которые оказались <strong>НЕ ЗАДЕЙСТВОВАНЫ</strong> в текущем билде. Потому что если мы их не юзали, в следующий раз они скорее всего не понадобятся.</ol><p>Получается следующая схема:</p><center> <img src=vacuum-cache-keys-algo.svg width=50%> </center><p>После такой чистки в директории <code>caches/build-cache-1</code> <del><sup>начался сущий кошмар</sup></del> останется дистиллят, который будет достаточно легким для отгрузки/загрузки во время подготовки GitLab раннера. Но при этом будет достаточен для заметного ускорения следующего прогона.<h4 id=vakuumirovanie-kesha-distilliat>Вакуумирование кэша (дистиллят)<a aria-hidden=true class=anchor hidden href=#vakuumirovanie-kesha-distilliat>#</a></h4><p>Для описанной выше схемы чистки кэша, состоящей из двух шагов, нужно допилить метод <code>close()</code> в <code>CacheKeysHandlerService</code>:<pre class=language-kotlin data-lang=kotlin style=background:#2b303b;color:#6c7079><code class=language-kotlin data-lang=kotlin><span style=color:#cd74e8>internal abstract class </span><span style=color:#f0c678>CacheKeysHandlerService</span><span style=color:#abb2bf> @</span><span style=color:#f0c678>Inject constructor</span><span style=color:#abb2bf>(
</span><span style=color:#abb2bf>    </span><span style=color:#adb7c9>gradle:</span><span style=color:#abb2bf> Gradle,
</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>:
</span><span style=color:#abb2bf>    BuildService&LTCacheKeysHandlerService</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>Params>,
</span><span style=color:#abb2bf>    BuildOperationListener,
</span><span style=color:#abb2bf>    AutoCloseable {
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=font-style:italic;color:#5f697a>// написанный ранее код...
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>override fun </span><span style=color:#5cb3fa>close</span><span style=color:#abb2bf>() {
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>val </span><span style=color:#abb2bf>cacheKeysFile </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> parameters</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>cacheKeysFile</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>asFile</span><span style=color:#adb7c9>.</span><span style=color:#5cb3fa>get</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// Если файл с ключами не пустой, значит мы специально подсунули его на CI
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// В файле хранится список ключей прилетевших с master ветки, удаляем их
</span><span style=color:#abb2bf>        cacheKeysFile</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>useLines { snapshotCacheKeys </span><span style=color:#adb7c9>->
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> (key </span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> snapshotCacheKeys) {
</span><span style=color:#abb2bf>                check(buildCacheDir</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>resolve(key)</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>delete()) {
</span><span style=color:#abb2bf>                    </span><span style=color:#9acc76>"Unable to delete cache key file: </span><span style=color:#eb6772>$key</span><span style=color:#9acc76>"
</span><span style=color:#abb2bf>                }
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// Записываем в файл новые ключики, дальше на CI разберутся что с ними делать
</span><span style=color:#abb2bf>        cacheKeysFile</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>bufferedWriter()</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>use { writer </span><span style=color:#adb7c9>->
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> (key </span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> cacheKeys) {
</span><span style=color:#abb2bf>                writer</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>appendLine(key)
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        </span><span style=font-style:italic;color:#5f697a>// Удаляем все кэш-ключи, не вошедшие в текущий билд
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>val </span><span style=color:#abb2bf>unusedCacheKeys </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> iterateBuildCache { it </span><span style=color:#adb7c9>!</span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> cacheKeys }
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> (key </span><span style=color:#cd74e8>in</span><span style=color:#abb2bf> unusedCacheKeys) {
</span><span style=color:#abb2bf>            check(buildCacheDir</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>resolve(key)</span><span style=color:#adb7c9>.</span><span style=color:#abb2bf>delete()) {
</span><span style=color:#abb2bf>                </span><span style=color:#9acc76>"Unable to delete cache key file: </span><span style=color:#eb6772>$key</span><span style=color:#9acc76>"
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>}
</span></code></pre><h4 id=peredaem-spisok-kesh-kliuchei-iz-master-v-mry>Передаем список кэш-ключей из master в МРы<a aria-hidden=true class=anchor hidden href=#peredaem-spisok-kesh-kliuchei-iz-master-v-mry>#</a></h4><p>Джоба, генерирующая кэш на CI, что гоняется при мерже в мастер, теперь будет отгружать архив не только с содержимым директории <code>$GRADLE_USER_HOME/caches/build-cache-1</code>, но и файлик <code>cache-keys.txt</code>. Джобы, запускаемые в МРах, будут чистить свой кэш от лишних ключей ориентируясь на этот файл. То, что останется, будет сохраняться для дальнейших прогонов:</p><img src=branch-specific-cache-sequence.svg width=100%><p>Редактируем определение билд-кэша в GitLab:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=font-style:italic;color:#5f697a># cache.yml
</span><span style=color:#abb2bf>
</span><span style=color:#eb6772>.pull-build-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-build
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/build-cache-1/
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>cache-keys.txt  </span><span style=font-style:italic;color:#5f697a># &LT-- Добавили
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Удаляем .push-build-cache
</span><span style=font-style:italic;color:#5f697a># Добавляем вот это:
</span><span style=color:#eb6772>.pull-push-build-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>cache-build
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull-push
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/build-cache-1/
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>cache-keys.txt  </span><span style=font-style:italic;color:#5f697a># &LT-- Добавили
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Добавляем определение для "branch specific cache"
</span><span style=color:#eb6772>.pull-push-branch-specific-cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  - </span><span style=color:#eb6772>key</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>"$CI_JOB_NAME-$CI_COMMIT_REF_SLUG"
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>policy</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>pull-push
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>unprotect</span><span style=color:#abb2bf>: </span><span style=color:#db9d63>true
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>paths</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>      - </span><span style=color:#9acc76>.gradle/caches/build-cache-1/
</span><span style=color:#abb2bf>      </span><span style=font-style:italic;color:#5f697a># А вот тут нет `cache-keys.txt`, это важно
</span><span style=color:#abb2bf>
</span></code></pre><p>Применяем новые кэши к нашим джобам:<pre class=language-yaml data-lang=yaml style=background:#2b303b;color:#6c7079><code class=language-yaml data-lang=yaml><span style=color:#eb6772>.base</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>variables</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>GRADLE_USER_HOME</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PROJECT_DIR/.gradle
</span><span style=color:#abb2bf>  </span><span style=font-style:italic;color:#5f697a># Тут какие-то еще базовые настройки, которые я пропустил
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>before_script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    </span><span style=font-style:italic;color:#5f697a># Врубаем наш плагин! А то ничо не заработает
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>mkdir -p $GRADLE_USER_HOME
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>echo "com.example.build.cache-keys.enabled=true" >> $GRADLE_USER_HOME/gradle.properties
</span><span style=color:#abb2bf>    - </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>after_script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#db9d63>...
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Эта джоба запускается в МРе
</span><span style=color:#eb6772>build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>stage</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>check
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>extends</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>.base
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>./gradlew :app:assembleDebug
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-wrapper-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-deps-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-build-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-push-branch-specific-cache </span><span style=color:#abb2bf>]  </span><span style=font-style:italic;color:#5f697a># &LT-- Добавили
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>rules</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#eb6772>if</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PIPELINE_SOURCE = "merge_request_event"
</span><span style=color:#abb2bf>
</span><span style=font-style:italic;color:#5f697a># Эта джоба запускается после вливания МРа
</span><span style=color:#eb6772>cache build</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>stage</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>post-check
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>extends</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>.base
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>script</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#9acc76>./gradlew :app:assembleDebug
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>cache</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.pull-push-wrapper-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-deps-cache </span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    - </span><span style=color:#cd74e8>!reference </span><span style=color:#abb2bf>[ </span><span style=color:#9acc76>.push-push-build-cache </span><span style=color:#abb2bf>]  </span><span style=font-style:italic;color:#5f697a># &LT-- Изменили
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>rules</span><span style=color:#abb2bf>:
</span><span style=color:#abb2bf>    - </span><span style=color:#eb6772>if</span><span style=color:#abb2bf>: </span><span style=color:#9acc76>$CI_PIPELINE_SOURCE = "push" && $CI_COMMIT_BRANCH == "master"
</span></code></pre><h4 id=zapuskaem-i-ubezhdaemsia-chto-vse-rabotaet>Запускаем и убеждаемся, что все работает<a aria-hidden=true class=anchor hidden href=#zapuskaem-i-ubezhdaemsia-chto-vse-rabotaet>#</a></h4><p>Теперь при создании МРа, первый прогон джобы build будет использовать кэш из ветки master. Чем ближе ваша ветка к ветке master, тем выше будет cache-hit.<p>При повторных прогонах МРа в дополнение к кэшу из master будет использован и кэш из предыдущего прогона.<h2 id=kak-eto-debazhit>Как это дебажить?<a aria-hidden=true class=anchor hidden href=#kak-eto-debazhit>#</a></h2><p>Нельзя верить мне на слово. Если вдруг появится жгучее желание не просто скопировать код отсюда, но и убедиться в том что он работает, можно проверить работу плагина локально. Для локальной отладки рекомендую указать альтернативный путь для переменной окружения <code>$GRADLE_USER_HOME</code>. По дефолту, если переменная не указна, Gradle хранит данные в <code>$USER_HOME/.gradle</code>, и при отладке ты будешь дропать билд кэш вообще всех проектов что есть у тебя на компуктере.<p>Также напоминаю, что во время отладки нужно отключать configuration cache и перед каждым замером чистить build директории модулей через твой любимый bash скрипт либо через <code>./gradlew clean</code>.<p>Подготовительная работа перед измерением качества работы плагина следующая:<ol start=0><li>Включаешь плагин через <code>gradle.properties</code>: <pre class=language-properties data-lang=properties style=background:#2b303b;color:#6c7079><code class=language-properties data-lang=properties><span style=color:#abb2bf>com.example.build.cache-keys.enabled=</span><span style=color:#9acc76>true
</span></code></pre><li>Удаляешь файлик <code>cache-keys.txt</code>, если он есть.<li>Собираешь проект с опцией <code>--scan</code>.<li>Удаляешь файлик <code>cache-keys.txt</code>.<li>Чистишь build директории.<li>Удаляешь файлик <code>cache-keys.txt</code>.</ol><p>После этих шагов у тебя будет билд-кэш, из которого удалены ВСЕ ключи, кроме использованных в билде. Файлик с ключами мы удаляем чтобы в в каждом следующем билде наш плагин не дропал ключи из него, думая что это ключи из master ветки.<p>Собственно, измерения:<ol><li>Собираешь проект с опцией <code>--scan</code>. На том кэше который остался после чистки с прошлого билда.<li>Открываешь BuildScan и смотришь Cache Hit. Он должен быть 100% (либо более 95%, если есть какие-то проблемы с кэш-миссами).</ol><p>Информацию о проценте попаданий в кэш тоже можно собирать с помощью плагина, но это тема уже раскрыта в <a href="https://mobiusconf.com/en/archive/2024%20Spring/talks/f9f7e56446a7462eb8e3e4ba6cc64770/?referer=%2Fen%2Farchive%2F2024%2520Spring%2Fpartners%2F42a2ee1c-85c9-4ceb-ba77-a0fe87f91cec%2F">докладе от Тинькофф на Mobius Spring 2024</a>.<h1 id=itogi>Итоги<a aria-hidden=true class=anchor hidden href=#itogi>#</a></h1><h2 id=kakie-est-minusy-u-resheniia-i-chto-mozhno-dorabotat>Какие есть минусы у решения и что можно доработать?<a aria-hidden=true class=anchor hidden href=#kakie-est-minusy-u-resheniia-i-chto-mozhno-dorabotat>#</a></h2><h3 id=ne-realizovana-ochistka-kesha-zavisimostei>Не реализована очистка кэша зависимостей<a aria-hidden=true class=anchor hidden href=#ne-realizovana-ochistka-kesha-zavisimostei>#</a></h3><p>Делается аналогично, но механизм отслеживания артефактов и чистка директорий с ними сложнее в реализации и требует больше кода. Возможно об этом я тоже напишу заметку в будущем.<p><strong>Важно:</strong> текущего решения уже более чем достаточно даже для средних по размерам проектов.<h3 id=posledovatel-nye-zapuski-gradle-lomaiut-logiku>Последовательные запуски gradle ломают логику<a aria-hidden=true class=anchor hidden href=#posledovatel-nye-zapuski-gradle-lomaiut-logiku>#</a></h3><p>Я хотел продемонстрировать суть своего решения. Дополнительная логика очистки докручивается без проблем.<h3 id=nakaplivaem-spisok-vsekh-kliuchei-v-operativnoi-pamiati>Накапливаем список всех ключей в оперативной памяти<a aria-hidden=true class=anchor hidden href=#nakaplivaem-spisok-vsekh-kliuchei-v-operativnoi-pamiati>#</a></h3><p>Это правда может стать проблемой, если ключей будет много. Но я сознательно пошел на этот шаг из-за того что большая часть тасок вообще не поддерживает кэширование через build cache. По моим наблюдениям список кэш-ключей на проекте из 500 модулей может занимать до 200 килобайт памяти, поэтому смысла оптимизировать этот момент нет.<h3 id=slozhna>Сложна<a aria-hidden=true class=anchor hidden href=#slozhna>#</a></h3><p>А кому щас легко...<h2 id=o-khoroshem>О хорошем<a aria-hidden=true class=anchor hidden href=#o-khoroshem>#</a></h2><p>Представленное здесь решение можно считать одним из самых простых способов значительно сократить билд-тайм на CI, используя только бесплатные инструменты и не погружаясь в impact-анализ. В общем, топ за свои деньги.</div><footer class=post-footer><ul class=post-tags><li><a href=https://tonykolomeytsev.github.io/tags/gradle/>gradle</a><li><a href=https://tonykolomeytsev.github.io/tags/gitlab/>gitlab</a><li><a href=https://tonykolomeytsev.github.io/tags/android/>android</a><li><a href=https://tonykolomeytsev.github.io/tags/docker/>docker</a></ul><section class=comments><script async data-color=1d1e20 data-colorful=1 data-comments-limit=5 data-dark=1 data-dark-color=FFFFFF data-telegram-discussion=kekmech/43 id=tg-discussion-widget src=https://telegram.org/js/telegram-widget.js?22></script></section><nav class=paginav><a class=prev href=https://tonykolomeytsev.github.io/posts/deploy-to-robots-with-docker/> <span class=title>« Prev</span> <br> <span>Опыт Eurobot: Деплой Docker образов на роботов в локальной сети</span> </a><a class=next href=https://tonykolomeytsev.github.io/posts/esoteric-gradle-optimizations-reject-android-return-to-kotlin-jvm/> <span class=title>Next »</span> <br> <span>Gradle заставляет избавляться от Android-модулей</span> </a></nav></footer></article></main><footer class=footer><span>© 2024 <a href=https://tonykolomeytsev.github.io>Anton Kolomeytsev</a></span><span> Powered by <a rel="noopener noreferrer" href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/cydave/zola-theme-papermod rel=noopener target=_blank>PaperMod</a> </span></footer><a aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g class=top-link href=#top id=top-link> <svg viewbox="0 0 12 6" fill=currentColor xmlns=http://www.w3.org/2000/svg><path d="M12 6H0l6-6z"/></svg> </a><script>let menu=document.getElementById('menu');if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}};document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var c=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(c)}']`).scrollIntoView({behavior:"smooth"})}else{document.querySelector(`[id='${decodeURIComponent(c)}']`).scrollIntoView()};if(c==="top"){history.replaceState(null,null," ")}else{history.pushState(null,null,`#${c}`)}})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1"}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0"}}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light')}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark')}})</script><script>document.querySelectorAll('pre > code').forEach(a=>{const c=a.parentNode.parentNode;const d=document.createElement('button');d.classList.add('copy-code');d.innerText='copy';function b(){d.innerText='copied!';setTimeout(()=>{d.innerText='copy'},2000)}d.addEventListener('click',e=>{if('clipboard' in navigator){navigator.clipboard.writeText(a.textContent);b();return};const f=document.createRange();f.selectNodeContents(a);const g=window.getSelection();g.removeAllRanges();g.addRange(f);try{document.execCommand('copy');b()}catch(h){};g.removeRange(f)});if(c.classList.contains("highlight")){c.appendChild(d)}else if(c.parentNode.firstChild==c){}else if(a.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){a.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(d)}else{a.parentNode.appendChild(d)}})</script>